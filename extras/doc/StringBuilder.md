# StringBuilder

StringBuilder is a heap-based dynamic buffer with many common string operations built in.
Despite the name, it is trivial to use StringBuilder for unsigned strings, and most of
the API is built to handle buffers safely without null-termination.

## Constraints

The class is built on a linked list that stores chunks of the full string represented by the class.
Whenever an operation is called that needs the string to be a single continuous buffer, the class
allocates double its string size from the heap and re-writes the data into the single buffer.

The collapsed string takes slightly less memory than the unified string, but the process of
"defragmenting" the string takes time and memory. It also changes the pointer used to hold the
unified string. Therefore, pointers returned by `string()` should only be considered valid as
long as the StringBuilder object remains unchanged.

StringBuilder's destructor will free any memory allocated by the class, which includes references
previously returned by `string()`. Any pointer generated by an instance of StringBuilder will only
remain valid for as long as that instance is in-scope.


## Conventional usage examples

```
StringBuilder str;
str.concat("This is a ");
str.concat("string created ");
str.concat("via piecemeal ");
str.concat("assembly.\n");

// Calling this will silently re-arrange the heap memory to produce and return
//   a single contiguous string.
str.string();  
```

## Tactical abuse of StringBuilder

On the surface, StringBuilder's primary purpose is to build and manipulate strings. But since
so many high-level capabilities in programming are derived from that simple ability, StringBuilder
has been employed in a number of off-label uses.

### Use as a data structure

Because StringBuilder is built on top of an ordered list, and because the list is casually
exposed to client classes, the list structure can be used as a kind of queue, or an array.

See the [AudemeMOVI](https://github.com/jspark311/ManuvrDrivers/blob/master/src/AudemeMOVI/AudemeMOVI.h) driver in ManuvrDrivers for a
canonical example of this type of usage (specifically the `_response` and `_vocabulary` members).

A number of functions within StringBuilder silently manipulate the list, and so foreknowledge
of those which functions do so is critical to using StringBuilder in this fashion.

Generally, anything that could potentially change the length of the string will result in list alteration:
    * `int  replace(const char*, const char*)`
    * `void cull(int offset, int length)`
    * `void cull(int length)`
    * `void trim()`
    * `void clear()`
    * Any function with `concat` or `prepend` in the name, including the `Handoff` variants.

As will anything that uses the tokenizer API:
    * `int  chunk(int)`
    * `int  split(const char*)`
    * `int  implode(const char*)`
    * `bool drop_position(unsigned int pos)`

If your usage of StringBuilder is mindful about calling these functions under controlled conditions (or abstains from their use entirely),
you can safely use the `position()` accessors to read the discrete pieces of the string, and they will remain where you leave them.


## Common mistakes in usage

### Use under concurrency

StringBuilder's internal mechanisms have little innate protection against concurrent modification (which includes calling `string()`). So any usage under threading or interrupts relies on heap safety under those same conditions, and is prone to failure without other measures of control outside of StringBuilder itself.

### Use of expired pointers

A easy mistake to commit would be this....

```
SomeNonblockingClass io_processor;
StringBuilder str("StringContent to be fed to a non-blocking function.");
io_processor.send(str.string());  // If io_processor doesn't deep-copy the string....
str.concat("More data added.");   // ...then this data will not be included by the pointer...
str.string();                     // ...and this line will invalidate the pointer entirely.

// Someplace later in the program, this sort of thing is likely to cause a hardfault.
io_processor.handle_string();  
```

Or another way to cause the same fault...

```
char* buffer = nullptr;
int light_count = getLightCount();
if (4 == light_count) {
  StringBuilder str;
  str.concatf("There are %d lights!");
  buffer = (char*) str.string();
}

// This will crash because str went out-of-scope, and StringBuilder's destructor
//   will have free'd the memory referenced by the pointer, but buffer is still non-null.
if (buffer) {
  printf("%s\n", buffer);
}
```
